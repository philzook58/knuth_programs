\input cwebmac
\datethis

\N{1}{1}Intro. This program is part of a series of ``exact cover solvers'' that
I'm putting together for my own education as I prepare to write Section
7.2.2.1 of {\sl The Art of Computer Programming}. My intent is to
have a variety of compatible programs on which I can run experiments,
in order to learn how different approaches work in practice.

Instead of actually solving an exact cover problem, {\mc DLX-PRE}
is a {\it preprocessor\/}: It converts the problem on \PB{\\{stdin}} to
an equivalent problem on \PB{\\{stdout}}, removing any options or items
that it finds to be unnecessary.

Here's a description of the input (and output) format, copied from
{\mc DLX1}:
We're given a matrix of 0s and 1s, some of whose items are called
``primary'' while the other items are ``secondary.''
Every option contains a~1 in at least one primary item.
The problem is to find all subsets of its options whose sum is
(i)~{\it exactly\/}~1 in all primary items;
(ii)~{\it at most\/}~1 in all secondary items.

This matrix, which is typically very sparse, is specified on \PB{\\{stdin}}
as follows:
\smallskip\item{$\bullet$} Each item has a symbolic name,
from one to eight characters long. Each of those characters can
be any nonblank ASCII code except for `\.{:}' and~`\.{\char"7C}'.
\smallskip\item{$\bullet$} The first line of input contains the
names of all primary items, separated by one or more spaces,
followed by `\.{\char"7C}', followed by the names of all other items.
(If all items are primary, the~`\.{\char"7C}' may be omitted.)
\smallskip\item{$\bullet$} The remaining lines represent the options,
by listing the items where 1~appears.
\smallskip\item{$\bullet$} Additionally, ``comment'' lines can be
interspersed anywhere in the input. Such lines, which begin with
`\.{\char"7C}', are ignored by this program, but they are often
useful within stored files.
\smallskip\noindent
Later versions of this program solve more general problems by
making further use of the reserved characters `\.{:}' and~`\.{\char"7C}'
to allow additional kinds of input.

For example, if we consider the matrix
$$\pmatrix{0&0&1&0&1&1&0\cr 1&0&0&1&0&0&1\cr 0&1&1&0&0&1&0\cr
1&0&0&1&0&0&0\cr 0&1&0&0&0&0&1\cr 0&0&0&1&1&0&1\cr}$$
which was (3) in my original paper, we can name the items
\.A, \.B, \.C, \.D, \.E, \.F,~\.G. Suppose the first five are
primary, and the latter two are secondary. That matrix can be
represented by the lines
$$
\vcenter{\halign{\tt#\cr
\char"7C\ A simple example\cr
A B C D E \char"7C\ F G\cr
C E F\cr
A D G\cr
B C F\cr
A D\cr
B G\cr
D E G\cr}}
$$
(and also in many other ways, because item names can be given in
any order, and so can the individual options). It has a unique solution,
consisting of the three options \.{A D} and \.{E F C} and \.{B G}.

{\mc DLX-PRE} will simplify this drastically. First it will observe
that every option containing \.A also contains \.D; hence item \.D can
be removed from the matrix, as can the option \.{D E G}. Similarly
we can remove item \.F; then item \.C and option \.{B C}.
Now we can remove \.G and option \.{A G}. The result is a trivial
problem, with three primary items \.A, \.B, \.E, and
three singleton options \.A, \.B, \.E.

\fi

\M{2}Furthermore, {\mc DLX2} extends {\mc DLX1} by allowing ``color controls.''
Any option that specifies a ``color'' in a nonprimary item will rule out all
options that don't specify the same color in that item.
But any number of options whose
nonprimary items agree in color are allowed. (The previous
situation was the special case in which every option corresponds to a
distinct color.)

The input format is extended so that, if \.{xx} is the name of a nonprimary
item, options can contain entries of the form \.{xx:a}, where \.a is
a single character (denoting a color).

Here, for example, is a simple test case:
$$
\vcenter{\halign{\tt#\cr
\char"7C\ A simple example of color controls\cr
A B C \char"7C\ X Y\cr
A B X:0 Y:0\cr
A C X:1 Y:1\cr
X:0 Y:1\cr
B X:1\cr
C Y:1\cr}}
$$
The option \.{X:0 Y:1} will be deleted immediately,
because it has no primary items.
The preprocessor will delete option \.{A B X:0 Y:0}, because that option
can't be used without making item \.C uncoverable.
Then item \.C can be eliminated, and option \.{C Y:1}.

\fi

\M{3}These examples show that the simplified output may be drastically
different from the original. It will have the same number of solutions;
but by looking only at the simplified options in those solutions,
you may have no idea how to actually resolve the original
problem! (Unless you work backward from
the simplifications that were actually performed.)

The preprocessor for my {\mc SAT} solvers had a counterpart called
`{\mc ERP}', which converted solutions of the preprocessed problems
into solutions of the original problems. {\mc DLX-PRE} doesn't
have that. But if you use the \PB{\\{show\_orig\_nos}} option below,
for example by saying `\.{v9}' when running {\mc DLX-PRE}, you
can figure out which options of the original are solutions. The sets
of options that solve the simplified problem are the sets of options
that solve the original problem; the numbers given as comments
by \PB{\\{show\_orig\_nos}} provide the mapping between solutions.

For example, the simplified output from the first problem,
using `\.{v9}', is:
$$\vcenter{\halign{\tt#\cr
A B C \char"7C\cr
A\cr
\char"7C\ (from 4)\cr
B\cr
\char"7C\ (from 5)\cr
C\cr
\char"7C\ (from 1)\cr
}}$$
And from the second problem it is similar, but not quite as simple:
$$\vcenter{\halign{\tt#\cr
A B \char"7C\ X Y\cr
A X:1 Y:1\cr
\char"7C\ (from 2)\cr
B X:1\cr
\char"7C\ (from 3)\cr
}}$$

\fi

\M{4}Most of the code below, like the description above, has been cribbed
from {\mc DLX2}, with minor changes.

After this program does its work, it reports its
running time in ``mems''; one ``mem'' essentially means a
memory access to a 64-bit word.
(The given totals don't include the time or space needed to parse the
input or to format the output.)

Here is the overall structure:

\Y\B\4\D$\|o$ \5
$\\{mems}\PP{}$\C{ count one mem }\par
\B\4\D$\\{oo}$ \5
$\\{mems}\MRL{+{\K}}{}$\T{2}\C{ count two mems }\par
\B\4\D$\\{ooo}$ \5
$\\{mems}\MRL{+{\K}}{}$\T{3}\C{ count three mems }\par
\B\4\D$\|O$ \5
\.{"\%"}\C{ used for percent signs in format strings }\par
\B\4\D$\\{mod}$ \5
$\MOD{}$\C{ used for percent signs denoting remainder in \CEE/ }\par
\B\4\D$\\{max\_level}$ \5
\T{500}\C{ at most this many options in a solution }\par
\B\4\D$\\{max\_itms}$ \5
\T{100000}\C{ at most this many items }\par
\B\4\D$\\{max\_nodes}$ \5
\T{10000000}\C{ at most this many nonzero elements in the matrix }\par
\B\4\D$\\{bufsize}$ \5
$(\T{9}*\\{max\_itms}+\T{3}{}$)\C{ a buffer big enough to hold all item names }%
\par
\Y\B\8\#\&{include} \.{<stdio.h>}\6
\8\#\&{include} \.{<stdlib.h>}\6
\8\#\&{include} \.{<string.h>}\6
\8\#\&{include} \.{<ctype.h>}\6
\8\#\&{include} \.{"gb\_flip.h"}\6
\&{typedef} \&{unsigned} \&{int} \&{uint};\C{ a convenient abbreviation }\6
\&{typedef} \&{unsigned} \&{long} \&{long} \&{ullng};\C{ ditto }\7
\X7:Type definitions\X;\6
\X5:Global variables\X;\6
\X11:Subroutines\X;\7
\\{main}(\&{int} \\{argc}${},\39{}$\&{char} ${}{*}\\{argv}[\,]){}$\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|c${},{}$ \\{cc}${},{}$ \\{dd}${},{}$ \|i${},{}$ %
\|j${},{}$ \|k${},{}$ \|p${},{}$ \\{pp}${},{}$ \|q${},{}$ \\{qq}${},{}$ %
\|r${},{}$ \\{rr}${},{}$ \\{rrr}${},{}$ \|t${},{}$ \\{uu}${},{}$ \|x${},{}$ %
\\{cur\_node}${},{}$ \\{best\_itm};\7
\X6:Process the command line\X;\6
\X16:Input the item names\X;\6
\X19:Input the options\X;\6
\&{if} ${}(\\{vbose}\AND\\{show\_basics}){}$\1\5
\X23:Report the successful completion of the input phase\X;\2\6
\&{if} ${}(\\{vbose}\AND\\{show\_tots}){}$\1\5
\X24:Report the item totals\X;\2\6
${}\\{imems}\K\\{mems},\39\\{mems}\K\T{0};{}$\6
\X29:Reduce the problem\X;\6
\4\\{finish}:\5
\X43:Output the reduced problem\X;\6
\4\\{done}:\5
\&{if} ${}(\\{vbose}\AND\\{show\_tots}){}$\1\5
\X24:Report the item totals\X;\2\6
\4\\{all\_done}:\5
\&{if} ${}(\\{vbose}\AND\\{show\_basics}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Removed\ "}\|O\.{"d\ option"}\|O\.{"s\ and\ "}%
\|O\.{"d\ item"}\|O\.{"s,\ after\ "}\|O\.{"llu+"}\|O\.{"llu\ mems,"},\39%
\\{options\_out},\39\\{options\_out}\E\T{1}\?\.{""}:\.{"s"},\39\\{itms\_out},%
\39\\{itms\_out}\E\T{1}\?\.{""}:\.{"s"},\39\\{imems},\39\\{mems});{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"d\ round"}\|O\.{"s.\\n"},\39%
\\{rnd},\39\\{rnd}\E\T{1}\?\.{""}:\.{"s"});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{5}You can control the amount of output,
as well as certain properties of the algorithm,
by specifying options on the command line:
\smallskip\item{$\bullet$}
`\.v$\langle\,$integer$\,\rangle$' enables or disables various kinds of verbose
output on \PB{\\{stderr}}, given by binary codes such as \PB{\\{show%
\_choices}};
\item{$\bullet$}
`\.d$\langle\,$integer$\,\rangle$' to sets \PB{\\{delta}}, which causes
periodic
state reports on \PB{\\{stderr}} after the algorithm has performed
approximately
\PB{\\{delta}} mems since the previous report (default 10000000000);
\item{$\bullet$}
`\.t$\langle\,$positive integer$\,\rangle$' to specify the maximum number of
rounds of option elimination that will be attempted.
\item{$\bullet$}
`\.T$\langle\,$integer$\,\rangle$' sets \PB{\\{timeout}} (which causes abrupt
termination if \PB{$\\{mems}>\\{timeout}$} at the beginning of a clause, but
doesn't
ruin the integrity of the output).

\Y\B\4\D$\\{show\_basics}$ \5
\T{1}\C{ \PB{\\{vbose}} code for basic stats; this is the default }\par
\B\4\D$\\{show\_choices}$ \5
\T{2}\C{ \PB{\\{vbose}} code for general logging }\par
\B\4\D$\\{show\_details}$ \5
\T{4}\C{ \PB{\\{vbose}} code for further commentary }\par
\B\4\D$\\{show\_orig\_nos}$ \5
\T{8}\C{ \PB{\\{vbose}} code to identify sources of output options }\par
\B\4\D$\\{show\_tots}$ \5
\T{512}\C{ \PB{\\{vbose}} code for reporting item totals at start and end }\par
\B\4\D$\\{show\_warnings}$ \5
\T{1024}\C{ \PB{\\{vbose}} code for reporting options without primaries }\par
\Y\B\4\X5:Global variables\X${}\E{}$\6
\&{int} \\{vbose}${}\K\\{show\_basics}{}$;\C{ level of verbosity }\6
\&{char} \\{buf}[\\{bufsize}];\C{ input buffer }\6
\&{ullng} \\{options};\C{ options seen so far }\6
\&{ullng} \\{imems}${},{}$ \\{mems};\C{ mem counts }\6
\&{ullng} \\{thresh}${}\K\T{1000000000}{}$;\C{ report when \PB{\\{mems}}
exceeds this, if \PB{$\\{delta}\I\T{0}$} }\6
\&{ullng} \\{delta}${}\K\T{10000000000}{}$;\C{ report every \PB{\\{delta}} or
so mems }\6
\&{ullng} \\{timeout}${}\K\T{\^1fffffffffffffff}{}$;\C{ give up after this many
mems }\6
\&{int} \\{rounds}${}\K\\{max\_nodes}{}$;\C{ maximum number of rounds attempted
}\6
\&{int} \\{options\_out}${},{}$ \\{itms\_out};\C{ this many reductions made so
far }\par
\As9\ET30.
\U4.\fi

\M{6}If an option appears more than once on the command line, the first
appearance takes precedence.

\Y\B\4\X6:Process the command line\X${}\E{}$\6
\&{for} ${}(\|j\K\\{argc}-\T{1},\39\|k\K\T{0};{}$ \|j; ${}\|j\MM){}$\1\6
\&{switch} (\\{argv}[\|j][\T{0}])\5
${}\{{}$\1\6
\4\&{case} \.{'v'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{vbose})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'d'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{delta})-\T{1}),\39\\{thresh}\K\\{delta}{}$;\5
\&{break};\6
\4\&{case} \.{'t'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"d"},\39{%
\AND}\\{rounds})-\T{1}){}$;\5
\&{break};\6
\4\&{case} \.{'T'}:\5
${}\|k\MRL{{\OR}{\K}}(\\{sscanf}(\\{argv}[\|j]+\T{1},\39\.{""}\|O\.{"lld"},\39{%
\AND}\\{timeout})-\T{1}){}$;\5
\&{break};\6
\4\&{default}:\5
${}\|k\K\T{1}{}$;\C{ unrecognized command-line option }\6
\4${}\}{}$\2\2\6
\&{if} (\|k)\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Usage:\ "}\|O\.{"s\ [v<n>]\ [d<n>]\ [t<}\)%
\.{n>]\ [T<n>]\ <\ foo.dlx}\)\.{\ >\ bar.dlx\\n"},\39\\{argv}[\T{0}]);{}$\6
${}\\{exit}({-}\T{1});{}$\6
\4${}\}{}$\2\par
\U4.\fi

\N{1}{7}Data structures.
Each item of the input matrix is represented by a \&{item} struct,
and each option is represented as a list of \&{node} structs. There's one
node for each nonzero entry in the matrix.

More precisely, the nodes of individual options appear sequentially,
with ``spacer'' nodes between them. The nodes are also
linked circularly within each item, in doubly linked lists.
The item lists each include a header node, but the option lists do not.
Item header nodes are aligned with a \&{item} struct, which
contains further info about the item.

Each node contains four important fields. Two are the pointers \PB{\\{up}}
and \PB{\\{down}} of doubly linked lists, already mentioned.
A~third points directly to the item containing the node.
And the last specifies a color, or zero if no color is specified.

A ``pointer'' is an array index, not a \CEE/ reference (because the latter
would occupy 64~bits and waste cache space). The \PB{\\{cl}} array is for
\&{item} structs, and the \PB{\\{nd}} array is for \&{node}s. I assume that
both of
those arrays are small enough to be allocated statically. (Modifications
of this program could do dynamic allocation if needed.)
The header node corresponding to \PB{\\{cl}[\|c]} is \PB{\\{nd}[\|c]}.

Notice that each \&{node} occupies two octabytes.
We count one mem for a simultaneous access to the \PB{\\{up}} and \PB{\\{down}}
fields,
or for a simultaneous access to the \PB{\\{itm}} and \PB{\\{color}} fields.

This program doesn't change the \PB{\\{itm}} fields after they've first been
set up,
except temporarily.
But the \PB{\\{up}} and \PB{\\{down}} fields will be changed frequently,
although preserving
relative order.

Exception: In the node \PB{\\{nd}[\|c]} that is the header for the list of
item~\PB{\|c}, we use the \PB{\\{itm}} field to hold the {\it length\/} of that
list (excluding the header node itself).
We also might use its \PB{\\{color}} field for special purposes.
The alternative names \PB{\\{len}} for \PB{\\{itm}} and \PB{\\{aux}} for \PB{%
\\{color}}
are used in the code so that this nonstandard semantics will be more clear.

A {\it spacer\/} node has \PB{$\\{itm}\Z\T{0}$}. Its \PB{\\{up}} field points
to the start
of the preceding option; its \PB{\\{down}} field points to the end of the
following option.
Thus it's easy to traverse an option circularly, in either direction.

Spacer nodes are also used {\it within\/} an option, if that option
has been shortened. The \PB{\\{up}} and \PB{\\{down}} fields in such spacers
simply point to the next and previous elements. (We~could optimize
this by collapsing links, for example when several spacers are
consecutive. But the present program doesn't do that.)

\Y\B\4\D$\\{len}$ \5
\\{itm}\C{ item list length (used in header nodes only) }\par
\B\4\D$\\{aux}$ \5
\\{color}\C{ an auxiliary quantity (used in header nodes only) }\par
\Y\B\4\X7:Type definitions\X${}\E{}$\6
\&{typedef} \&{struct} \&{node\_struct} ${}\{{}$\1\6
\&{int} \\{up}${},{}$ \\{down};\C{ predecessor and successor in item }\6
\&{int} \\{itm};\C{ the item containing this node }\6
\&{int} \\{color};\C{ the color specified by this node, if any }\2\6
${}\}{}$ \&{node};\par
\A8.
\U4.\fi

\M{8}Each \&{item} struct contains three fields:
The \PB{\\{name}} is the user-specified identifier;
\PB{\\{next}} and \PB{\\{prev}} point to adjacent items, when this
item is part of a doubly linked list.

We count one mem for a simultaneous access to the \PB{\\{prev}} and \PB{%
\\{next}} fields.

\Y\B\4\X7:Type definitions\X${}\mathrel+\E{}$\6
\&{typedef} \&{struct} \&{itm\_struct} ${}\{{}$\1\6
\&{char} \\{name}[\T{8}];\C{ symbolic identification of the item, for printing
}\6
\&{int} \\{prev}${},{}$ \\{next};\C{ neighbors of this item }\2\6
${}\}{}$ \&{item};\par
\fi

\M{9}\B\X5:Global variables\X${}\mathrel+\E{}$\6
\&{node} ${}{*}\\{nd}{}$;\C{ the master list of nodes }\6
\&{int} \\{last\_node};\C{ the first node in \PB{\\{nd}} that's not yet used }\6
\&{item} ${}\\{cl}[\\{max\_itms}+\T{2}]{}$;\C{ the master list of items }\6
\&{int} \\{second}${}\K\\{max\_itms}{}$;\C{ boundary between primary and
secondary items }\6
\&{int} \\{last\_itm};\C{ the first item in \PB{\\{cl}} that's not yet used }%
\par
\fi

\M{10}One \PB{\&{item}} struct is called the root. It serves as the head of the
list of items that need to be covered, and is identifiable by the fact
that its \PB{\\{name}} is empty.

\Y\B\4\D$\\{root}$ \5
\T{0}\C{ \PB{\\{cl}[\\{root}]} is the gateway to the unsettled items }\par
\fi

\M{11}an option is identified not by name but by the names of the items it
contains.
Here is a routine that prints an option, given a pointer to any of its
nodes. It also prints the position of the option in its item.

This procedure differs slightly from its counterpart in {\mc DLX2}: It
uses `\PB{\&{while}}' where {\mc DLX2} had `\PB{\&{if}}'. The reason is that
{\mc DLX-PRE} sometimes deletes nodes, replacing them by spacers.

\Y\B\4\X11:Subroutines\X${}\E{}$\6
\&{void} \\{print\_option}(\&{int} \|p${},\39{}$\&{FILE} ${}{*}\\{stream}){}$\1%
\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|k${},{}$ \|q;\7
\&{if} ${}(\|p<\\{last\_itm}\V\|p\G\\{last\_node}\V\\{nd}[\|p].\\{itm}\Z%
\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Illegal\ option\ "}\|O\.{"d!\\n"},\39\|p);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{for} ${}(\|q\K\|p;{}$  ; \,)\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ "}\|O\.{".8s"},\39\\{cl}[\\{nd}[\|q].%
\\{itm}].\\{name});{}$\6
\&{if} ${}(\\{nd}[\|q].\\{color}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{":"}\|O\.{"c"},\39\\{nd}[\|q].\\{color}>\T{0}\?%
\\{nd}[\|q].\\{color}:\\{nd}[\\{nd}[\|q].\\{itm}].\\{color});{}$\2\6
${}\|q\PP;{}$\6
\&{while} ${}(\\{nd}[\|q].\\{itm}\Z\T{0}){}$\1\5
${}\|q\K\\{nd}[\|q].\\{up};{}$\2\6
\&{if} ${}(\|q\E\|p){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|q\K\\{nd}[\\{nd}[\|p].\\{itm}].\\{down},\39\|k\K\T{1};{}$ ${}\|q%
\I\|p;{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|q\E\\{nd}[\|p].\\{itm}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ (?)\\n"}){}$;\5
\&{return};\C{ option not in its item! }\6
\4${}\}{}$\5
\2\&{else}\1\5
${}\|q\K\\{nd}[\|q].\\{down};{}$\2\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stream},\39\.{"\ ("}\|O\.{"d\ of\ "}\|O\.{"d)\\n"},\39\|k,\39%
\\{nd}[\\{nd}[\|p].\\{itm}].\\{len});{}$\6
\4${}\}{}$\2\7
\&{void} \\{prow}(\&{int} \|p)\1\1\2\2\6
${}\{{}$\1\6
${}\\{print\_option}(\|p,\39\\{stderr});{}$\6
\4${}\}{}$\2\par
\As12, 13, 14, 27\ETs28.
\U4.\fi

\M{12}Another routine to print options is used for diagnostics. It returns the
original number of the option, and displays the not-yet-deleted items
in their original order.
That original number (or rather its negative) appears in the spacer
at the right of the option.

\Y\B\4\X11:Subroutines\X${}\mathrel+\E{}$\6
\&{int} \\{dpoption}(\&{int} \|p${},\39{}$\&{FILE} ${}{*}\\{stream}){}$\1\1\2\2%
\6
${}\{{}$\1\6
\&{register} \&{int} \|q${},{}$ \|c;\7
\&{for} ${}(\|p\MM;{}$ ${}\\{nd}[\|p].\\{itm}>\T{0}\V\\{nd}[\|p].\\{down}<%
\|p;{}$ ${}\|p\MM){}$\1\5
;\2\6
\&{for} ${}(\|q\K\|p+\T{1};{}$  ; ${}\|q\PP){}$\5
${}\{{}$\1\6
${}\|c\K\\{nd}[\|q].\\{itm};{}$\6
\&{if} ${}(\|c<\T{0}){}$\1\5
\&{return} ${}{-}\|c;{}$\2\6
\&{if} ${}(\|c>\T{0}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stream},\39\.{"\ "}\|O\.{".8s"},\39\\{cl}[\|c].\\{name});{}$\6
\&{if} ${}(\\{nd}[\|q].\\{color}){}$\1\5
${}\\{fprintf}(\\{stream},\39\.{":"}\|O\.{"c"},\39\\{nd}[\|q].\\{color});{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{13}When I'm debugging, I might want to look at one of the current item
lists.

\Y\B\4\X11:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{print\_itm}(\&{int} \|c)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|p;\7
\&{if} ${}(\|c<\\{root}\V\|c\G\\{last\_itm}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Illegal\ item\ "}\|O\.{"d!\\n"},\39\|c);{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\|c<\\{second}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Item\ "}\|O\.{".8s,\ length\ "}\|O\.{"d,\
neighbors\ "}\|O\.{".8s\ and\ "}\|O\.{".8s:\\n"},\39\\{cl}[\|c].\\{name},\39%
\\{nd}[\|c].\\{len},\39\\{cl}[\\{cl}[\|c].\\{prev}].\\{name},\39\\{cl}[\\{cl}[%
\|c].\\{next}].\\{name});{}$\2\6
\&{else}\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Item\ "}\|O\.{".8s,\ length\ "}\|O\.{"d:\\n"},%
\39\\{cl}[\|c].\\{name},\39\\{nd}[\|c].\\{len});{}$\2\6
\&{for} ${}(\|p\K\\{nd}[\|c].\\{down};{}$ ${}\|p\G\\{last\_itm};{}$ ${}\|p\K%
\\{nd}[\|p].\\{down}){}$\1\5
\\{prow}(\|p);\2\6
\4${}\}{}$\2\par
\fi

\M{14}Speaking of debugging, here's a routine to check if redundant parts of
our
data structure have gone awry.

\Y\B\4\D$\\{sanity\_checking}$ \5
\T{0}\C{ set this to 1 if you suspect a bug }\par
\Y\B\4\X11:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{sanity}(\&{void})\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|k${},{}$ \|p${},{}$ \|q${},{}$ \\{pp}${},{}$ %
\\{qq}${},{}$ \|t;\7
\&{for} ${}(\|q\K\\{root},\39\|p\K\\{cl}[\|q].\\{next};{}$  ; ${}\|q\K\|p,\39%
\|p\K\\{cl}[\|p].\\{next}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{cl}[\|p].\\{prev}\I\|q){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Bad\ prev\ field\ at\ i}\)\.{tm\ "}\|O\.{".8s!%
\\n"},\39\\{cl}[\|p].\\{name});{}$\2\6
\&{if} ${}(\|p\E\\{root}){}$\1\5
\&{break};\2\6
\X15:Check item \PB{\|p}\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{15}\B\X15:Check item \PB{\|p}\X${}\E{}$\6
\&{for} ${}(\\{qq}\K\|p,\39\\{pp}\K\\{nd}[\\{qq}].\\{down},\39\|k\K\T{0};{}$  ;
${}\\{qq}\K\\{pp},\39\\{pp}\K\\{nd}[\\{pp}].\\{down},\39\|k\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{nd}[\\{pp}].\\{up}\I\\{qq}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Bad\ up\ field\ at\ nod}\)\.{e\ "}\|O\.{"d!%
\\n"},\39\\{pp});{}$\2\6
\&{if} ${}(\\{pp}\E\|p){}$\1\5
\&{break};\2\6
\&{if} ${}(\\{nd}[\\{pp}].\\{itm}\I\|p){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Bad\ itm\ field\ at\ no}\)\.{de\ "}\|O\.{"d!%
\\n"},\39\\{pp});{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{nd}[\|p].\\{len}\I\|k){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Bad\ len\ field\ in\ it}\)\.{em\ "}\|O\.{".8s!%
\\n"},\39\\{cl}[\|p].\\{name}){}$;\2\par
\U14.\fi

\N{1}{16}Inputting the matrix. Brute force is the rule in this part of the
code,
whose goal is to parse and store the input data and to check its validity.

\Y\B\4\D$\\{panic}(\|m)$ \6
${}\{{}$\5
\1${}\\{fprintf}(\\{stderr},\39\.{""}\|O\.{"s!\\n"}\|O\.{"d:\ "}\|O\.{".99s%
\\n"},\39\|m,\39\|p,\39\\{buf}){}$;\5
${}\\{exit}({-}\T{666}){}$;\5
${}\}{}$\2\par
\Y\B\4\X16:Input the item names\X${}\E{}$\6
$\\{nd}\K{}$(\&{node} ${}{*}){}$ \\{calloc}${}(\\{max\_nodes},\39\&{sizeof}(%
\&{node}));{}$\6
\&{if} ${}(\R\\{nd}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"I\ couldn't\ allocate}\)\.{\ space\ for\ "}\|O%
\.{"d\ nodes!\\n"},\39\\{max\_nodes});{}$\6
${}\\{exit}({-}\T{666});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{max\_nodes}\Z\T{2}*\\{max\_itms}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Recompile\ me:\ max\_n}\)\.{odes\ must\ exceed%
\ twi}\)\.{ce\ max\_itms!\\n"});{}$\6
${}\\{exit}({-}\T{999});{}$\6
\4${}\}{}$\C{ every item will want a header node and at least one other node }%
\2\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\&{if} ${}(\R\\{fgets}(\\{buf},\39\\{bufsize},\39\\{stdin})){}$\1\5
\&{break};\2\6
\&{if} ${}(\|o,\39\\{buf}[\|p\K\\{strlen}(\\{buf})-\T{1}]\I\.{'\\n'}){}$\1\5
\\{panic}(\.{"Input\ line\ way\ too\ }\)\.{long"});\2\6
\&{for} ${}(\|p\K\T{0};{}$ \|o${},\39\\{isspace}(\\{buf}[\|p]);{}$ ${}\|p%
\PP){}$\1\5
;\2\6
\&{if} ${}(\\{buf}[\|p]\E\.{'|'}\V\R\\{buf}[\|p]){}$\1\5
\&{continue};\C{ bypass comment or blank line }\2\6
${}\\{last\_itm}\K\T{1};{}$\6
\&{break};\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{last\_itm}){}$\1\5
\\{panic}(\.{"No\ items"});\2\6
\&{for} ( ; \|o${},\39\\{buf}[\|p];{}$ \,)\5
${}\{{}$\1\6
\&{for} ${}(\|j\K\T{0};{}$ ${}\|j<\T{8}\W(\|o,\39\R\\{isspace}(\\{buf}[\|p+%
\|j]));{}$ ${}\|j\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{buf}[\|p+\|j]\E\.{':'}\V\\{buf}[\|p+\|j]\E\.{'|'}){}$\1\5
\\{panic}(\.{"Illegal\ character\ i}\)\.{n\ item\ name"});\2\6
${}\|o,\39\\{cl}[\\{last\_itm}].\\{name}[\|j]\K\\{buf}[\|p+\|j];{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\|j\E\T{8}\W\R\\{isspace}(\\{buf}[\|p+\|j])){}$\1\5
\\{panic}(\.{"Item\ name\ too\ long"});\2\6
\X17:Check for duplicate item name\X;\6
\X18:Initialize \PB{\\{last\_itm}} to a new item with an empty list\X;\6
\&{for} ${}(\|p\MRL{+{\K}}\|j+\T{1};{}$ \|o${},\39\\{isspace}(\\{buf}[\|p]);{}$
${}\|p\PP){}$\1\5
;\2\6
\&{if} ${}(\\{buf}[\|p]\E\.{'|'}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{second}\I\\{max\_itms}){}$\1\5
\\{panic}(\.{"Item\ name\ line\ cont}\)\.{ains\ |\ twice"});\2\6
${}\\{second}\K\\{last\_itm};{}$\6
\&{for} ${}(\|p\PP;{}$ \|o${},\39\\{isspace}(\\{buf}[\|p]);{}$ ${}\|p\PP){}$\1\5
;\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\\{second}\E\\{max\_itms}){}$\1\5
${}\\{second}\K\\{last\_itm};{}$\2\6
${}\|o,\39\\{cl}[\\{root}].\\{prev}\K\\{second}-\T{1}{}$;\C{ \PB{$\\{cl}[%
\\{second}-\T{1}].\\{next}\K\\{root}$} since \PB{$\\{root}\K\T{0}$} }\6
${}\\{last\_node}\K\\{last\_itm}{}$;\C{ reserve all the header nodes and the
first spacer }\6
${}\|o,\39\\{nd}[\\{last\_node}].\\{itm}\K\T{0}{}$;\par
\U4.\fi

\M{17}\B\X17:Check for duplicate item name\X${}\E{}$\6
\&{for} ${}(\|k\K\T{1};{}$ \|o${},\39\\{strncmp}(\\{cl}[\|k].\\{name},\39%
\\{cl}[\\{last\_itm}].\\{name},\39\T{8});{}$ ${}\|k\PP){}$\1\5
;\2\6
\&{if} ${}(\|k<\\{last\_itm}){}$\1\5
\\{panic}(\.{"Duplicate\ item\ name}\)\.{"});\2\par
\U16.\fi

\M{18}\B\X18:Initialize \PB{\\{last\_itm}} to a new item with an empty list%
\X${}\E{}$\6
\&{if} ${}(\\{last\_itm}>\\{max\_itms}){}$\1\5
\\{panic}(\.{"Too\ many\ items"});\2\6
\&{if} ${}(\\{second}\E\\{max\_itms}){}$\1\5
${}\\{oo},\39\\{cl}[\\{last\_itm}-\T{1}].\\{next}\K\\{last\_itm},\39\\{cl}[%
\\{last\_itm}].\\{prev}\K\\{last\_itm}-\T{1};{}$\2\6
\&{else}\1\5
${}\|o,\39\\{cl}[\\{last\_itm}].\\{next}\K\\{cl}[\\{last\_itm}].\\{prev}\K%
\\{last\_itm}{}$;\C{ \PB{$\\{nd}[\\{last\_itm}].\\{len}\K\T{0}$} }\2\6
${}\|o,\39\\{nd}[\\{last\_itm}].\\{up}\K\\{nd}[\\{last\_itm}].\\{down}\K\\{last%
\_itm};{}$\6
${}\\{last\_itm}\PP{}$;\par
\U16.\fi

\M{19}In {\mc DLX1} and its descendants, I put the option number into the
spacer
that follows it, but only because I thought it might be a
possible debugging aid. Now, in {\mc DLX-PRE}, I'm glad I did,
because we need this number when the user wants to relate the simplified
output to the original unsimplified options.

\Y\B\4\X19:Input the options\X${}\E{}$\6
\&{while} (\T{1})\5
${}\{{}$\1\6
\&{if} ${}(\R\\{fgets}(\\{buf},\39\\{bufsize},\39\\{stdin})){}$\1\5
\&{break};\2\6
\&{if} ${}(\|o,\39\\{buf}[\|p\K\\{strlen}(\\{buf})-\T{1}]\I\.{'\\n'}){}$\1\5
\\{panic}(\.{"Option\ line\ too\ lon}\)\.{g"});\2\6
\&{for} ${}(\|p\K\T{0};{}$ \|o${},\39\\{isspace}(\\{buf}[\|p]);{}$ ${}\|p%
\PP){}$\1\5
;\2\6
\&{if} ${}(\\{buf}[\|p]\E\.{'|'}\V\R\\{buf}[\|p]){}$\1\5
\&{continue};\C{ bypass comment or blank line }\2\6
${}\|i\K\\{last\_node}{}$;\C{ remember the spacer at the left of this option }\6
\&{for} ${}(\\{pp}\K\T{0};{}$ \\{buf}[\|p]; \,)\5
${}\{{}$\1\6
\&{for} ${}(\|j\K\T{0};{}$ ${}\|j<\T{8}\W(\|o,\39\R\\{isspace}(\\{buf}[\|p+%
\|j]))\W\\{buf}[\|p+\|j]\I\.{':'};{}$ ${}\|j\PP){}$\1\5
${}\|o,\39\\{cl}[\\{last\_itm}].\\{name}[\|j]\K\\{buf}[\|p+\|j];{}$\2\6
\&{if} ${}(\R\|j){}$\1\5
\\{panic}(\.{"Empty\ item\ name"});\2\6
\&{if} ${}(\|j\E\T{8}\W\R\\{isspace}(\\{buf}[\|p+\|j])\W\\{buf}[\|p+\|j]\I%
\.{':'}){}$\1\5
\\{panic}(\.{"Item\ name\ too\ long"});\2\6
\&{if} ${}(\|j<\T{8}){}$\1\5
${}\|o,\39\\{cl}[\\{last\_itm}].\\{name}[\|j]\K\.{'\\0'};{}$\2\6
\X20:Create a node for the item named in \PB{\\{buf}[\|p]}\X;\6
\&{if} ${}(\\{buf}[\|p+\|j]\I\.{':'}){}$\1\5
${}\|o,\39\\{nd}[\\{last\_node}].\\{color}\K\T{0};{}$\2\6
\&{else} \&{if} ${}(\|k\G\\{second}){}$\5
${}\{{}$\1\6
\&{if} ${}((\|o,\39\\{isspace}(\\{buf}[\|p+\|j+\T{1}]))\V(\|o,\39\R\\{isspace}(%
\\{buf}[\|p+\|j+\T{2}]))){}$\1\5
\\{panic}(\.{"Color\ must\ be\ a\ sin}\)\.{gle\ character"});\2\6
${}\|o,\39\\{nd}[\\{last\_node}].\\{color}\K\\{buf}[\|p+\|j+\T{1}];{}$\6
${}\|p\MRL{+{\K}}\T{2};{}$\6
\4${}\}{}$\5
\2\&{else}\1\5
\\{panic}(\.{"Primary\ item\ must\ b}\)\.{e\ uncolored"});\2\6
\&{for} ${}(\|p\MRL{+{\K}}\|j+\T{1};{}$ \|o${},\39\\{isspace}(\\{buf}[\|p]);{}$
${}\|p\PP){}$\1\5
;\2\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{pp}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_warnings}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Option\ ignored\ (no\ }\)\.{primary\ items):\
"}\|O\.{"s"},\39\\{buf});{}$\2\6
\&{while} ${}(\\{last\_node}>\|i){}$\5
${}\{{}$\1\6
\X22:Remove \PB{\\{last\_node}} from its item\X;\6
${}\\{last\_node}\MM;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\5
\2\&{else}\5
${}\{{}$\1\6
${}\|o,\39\\{nd}[\|i].\\{down}\K\\{last\_node};{}$\6
${}\\{last\_node}\PP{}$;\C{ create the next spacer }\6
\&{if} ${}(\\{last\_node}\E\\{max\_nodes}){}$\1\5
\\{panic}(\.{"Too\ many\ nodes"});\2\6
${}\\{options}\PP;{}$\6
${}\|o,\39\\{nd}[\\{last\_node}].\\{up}\K\|i+\T{1};{}$\6
${}\|o,\39\\{nd}[\\{last\_node}].\\{itm}\K{-}\\{options};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U4.\fi

\M{20}\B\X20:Create a node for the item named in \PB{\\{buf}[\|p]}\X${}\E{}$\6
\&{for} ${}(\|k\K\T{0};{}$ \|o${},\39\\{strncmp}(\\{cl}[\|k].\\{name},\39%
\\{cl}[\\{last\_itm}].\\{name},\39\T{8});{}$ ${}\|k\PP){}$\1\5
;\2\6
\&{if} ${}(\|k\E\\{last\_itm}){}$\1\5
\\{panic}(\.{"Unknown\ item\ name"});\2\6
\&{if} ${}(\|o,\39\\{nd}[\|k].\\{aux}\G\|i){}$\1\5
\\{panic}(\.{"Duplicate\ item\ name}\)\.{\ in\ this\ option"});\2\6
${}\\{last\_node}\PP;{}$\6
\&{if} ${}(\\{last\_node}\E\\{max\_nodes}){}$\1\5
\\{panic}(\.{"Too\ many\ nodes"});\2\6
${}\|o,\39\\{nd}[\\{last\_node}].\\{itm}\K\|k;{}$\6
\&{if} ${}(\|k<\\{second}){}$\1\5
${}\\{pp}\K\T{1};{}$\2\6
${}\|o,\39\|t\K\\{nd}[\|k].\\{len}+\T{1};{}$\6
\X21:Insert node \PB{\\{last\_node}} into the list for item \PB{\|k}\X;\par
\U19.\fi

\M{21}Insertion of a new node is simple.
We store the position of the new node into \PB{$\\{nd}[\|k].\\{aux}$}, so that
the test for duplicate items above will be correct.

\Y\B\4\X21:Insert node \PB{\\{last\_node}} into the list for item \PB{\|k}\X${}%
\E{}$\6
$\|o,\39\\{nd}[\|k].\\{len}\K\|t{}$;\C{ store the new length of the list }\6
${}\\{nd}[\|k].\\{aux}\K\\{last\_node}{}$;\C{ no mem charge for \PB{\\{aux}}
after \PB{\\{len}} }\6
${}\|o,\39\|r\K\\{nd}[\|k].\\{up}{}$;\C{ the ``bottom'' node of the item list }%
\6
${}\\{ooo},\39\\{nd}[\|r].\\{down}\K\\{nd}[\|k].\\{up}\K\\{last\_node},\39%
\\{nd}[\\{last\_node}].\\{up}\K\|r,\39\\{nd}[\\{last\_node}].\\{down}\K\|k{}$;%
\par
\U20.\fi

\M{22}\B\X22:Remove \PB{\\{last\_node}} from its item\X${}\E{}$\6
$\|o,\39\|k\K\\{nd}[\\{last\_node}].\\{itm};{}$\6
${}\\{oo},\39\\{nd}[\|k].\\{len}\MM,\39\\{nd}[\|k].\\{aux}\K\|i-\T{1};{}$\6
${}\|o,\39\|q\K\\{nd}[\\{last\_node}].\\{up},\39\|r\K\\{nd}[\\{last\_node}].%
\\{down};{}$\6
${}\\{oo},\39\\{nd}[\|q].\\{down}\K\|r,\39\\{nd}[\|r].\\{up}\K\|q{}$;\par
\U19.\fi

\M{23}\B\X23:Report the successful completion of the input phase\X${}\E{}$\6
$\\{fprintf}(\\{stderr},\39\.{"("}\|O\.{"lld\ options,\ "}\|O\.{"d+"}\|O\.{"d\
items,\ "}\|O\.{"d\ entries\ successfu}\)\.{lly\ read)\\n"},\39\\{options},\39%
\\{second}-\T{1},\39\\{last\_itm}-\\{second},\39\\{last\_node}-\\{last%
\_itm}){}$;\par
\U4.\fi

\M{24}The item lengths after input should agree with the item lengths
after this program has finished---unless, of course, we've successfully
simplified the input! I print them (on request), in order to
provide some reassurance that the algorithm isn't badly screwed up.

\Y\B\4\X24:Report the item totals\X${}\E{}$\6
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"Item\ totals:"});{}$\6
\&{for} ${}(\|k\K\T{1};{}$ ${}\|k<\\{last\_itm};{}$ ${}\|k\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|k\E\\{second}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ |"});{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{"d"},\39\\{nd}[\|k].\\{len});{}$\6
\4${}\}{}$\2\6
${}\\{fprintf}(\\{stderr},\39\.{"\\n"});{}$\6
\4${}\}{}$\2\par
\U4.\fi

\N{1}{25}The dancing.
Suppose $p$ is a primary item, and $c$ is an arbitrary item such that
every option containing~$p$ also contains an uncolored instance of~$c$.
Then we can delete item~$c$,
and every option that contains $c$ but not~$p$. For we'll need to cover~$p$,
and then $c$ will automatically be covered too.

More generally, if $p$ is a primary item and $r$
is an option such that $p\notin r$ but every option containing~$p$ is
incompatible
with~$r$,
then we can eliminate option~$r$: That option can't be chosen without making
$p$ uncoverable.

This program exploits those two ideas, by systematically looking at
all options in the list for item~$c$, as $c$ runs through all items.

This algorithm takes ``polynomial time,'' but I don't claim that it is fast.
I~want to get a straightforward algorithm in place before trying to
make it more complicated.

On the other hand, I've tried to use the most efficient and scalable
methods that I could think of, consistent with that goal of relative
simplicity. There's no point in having a preprocessor unless it works
fast enough to speed up the total time of preprocessing plus processing.

\fi

\M{26}The basic operation is ``hiding an item.'' This means causing all of
the options in its list to be invisible from outside the item, except
for the options that color this item; they are
(temporarily) deleted from all other lists.

As in {\mc DLX2}, the neat part of this algorithm is the way the lists are
maintained. No auxiliary tables are needed when hiding an item, or
when unhiding it later. The nodes removed from doubly linked lists remember
their former neighbors, because we do no garbage collection.

\fi

\M{27}Hiding is much like {\mc DLX2}'s ``covering'' operation, but it
has a new twist:
If the process of hiding item $c$ causes at least one primary item~$p$
to become empty, we know that $c$ can be eliminated
(as mentioned above). Furthermore we know that we can delete every
option that contains $c$ but not~$p$.

Therefore the \PB{\\{hide}} procedure puts the value of such~$p$ in a global
variable, for use by the caller. That global variable is called
`\PB{\\{stack}}' for historical reasons: My first implementation had
an unnecessarily complex mechanism for dealing with several
primary items that simultaneously become empty, so I used to
put them onto a stack.

\Y\B\4\X11:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{hide}(\&{int} \|c)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \\{cc}${},{}$ \|l${},{}$ \|r${},{}$ \\{rr}${},{}$ %
\\{nn}${},{}$ \\{uu}${},{}$ \\{dd}${},{}$ \|t${},{}$ \|k${}\K\T{0};{}$\7
\&{for} ${}(\|o,\39\\{rr}\K\\{nd}[\|c].\\{down};{}$ ${}\\{rr}\G\\{last%
\_itm};{}$ \|o${},\39\\{rr}\K\\{nd}[\\{rr}].\\{down}){}$\1\6
\&{if} ${}(\|o,\39\R\\{nd}[\\{rr}].\\{color}){}$\5
${}\{{}$\1\6
\&{for} ${}(\\{nn}\K\\{rr}+\T{1};{}$ ${}\\{nn}\I\\{rr};{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{uu}\K\\{nd}[\\{nn}].\\{up},\39\\{dd}\K\\{nd}[\\{nn}].\\{down};{}$\6
${}\|o,\39\\{cc}\K\\{nd}[\\{nn}].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\\{nn}\K\\{uu};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\\{oo},\39\\{nd}[\\{uu}].\\{down}\K\\{dd},\39\\{nd}[\\{dd}].\\{up}\K%
\\{uu};{}$\6
${}\|o,\39\|t\K\\{nd}[\\{cc}].\\{len}-\T{1};{}$\6
${}\|o,\39\\{nd}[\\{cc}].\\{len}\K\|t;{}$\6
\&{if} ${}(\|t\E\T{0}\W\\{cc}<\\{second}){}$\1\5
${}\\{stack}\K\\{cc};{}$\2\6
${}\\{nn}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\par
\fi

\M{28}\B\X11:Subroutines\X${}\mathrel+\E{}$\6
\&{void} \\{unhide}(\&{int} \|c)\1\1\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \\{cc}${},{}$ \|l${},{}$ \|r${},{}$ \\{rr}${},{}$ %
\\{nn}${},{}$ \\{uu}${},{}$ \\{dd}${},{}$ \|t;\7
\&{for} ${}(\|o,\39\\{rr}\K\\{nd}[\|c].\\{down};{}$ ${}\\{rr}\G\\{last%
\_itm};{}$ \|o${},\39\\{rr}\K\\{nd}[\\{rr}].\\{down}){}$\1\6
\&{if} ${}(\|o,\39\R\\{nd}[\\{rr}].\\{color}){}$\5
${}\{{}$\1\6
\&{for} ${}(\\{nn}\K\\{rr}+\T{1};{}$ ${}\\{nn}\I\\{rr};{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{uu}\K\\{nd}[\\{nn}].\\{up},\39\\{dd}\K\\{nd}[\\{nn}].\\{down};{}$\6
${}\|o,\39\\{cc}\K\\{nd}[\\{nn}].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\\{nn}\K\\{uu};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\|o,\39\|t\K\\{nd}[\\{cc}].\\{len};{}$\6
${}\\{oo},\39\\{nd}[\\{uu}].\\{down}\K\\{nd}[\\{dd}].\\{up}\K\\{nn};{}$\6
${}\|o,\39\\{nd}[\\{cc}].\\{len}\K\|t+\T{1};{}$\6
${}\\{nn}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\par
\fi

\M{29}Here then is the main loop for each round of preprocessing.

\Y\B\4\X29:Reduce the problem\X${}\E{}$\6
\&{for} ${}(\\{cc}\K\T{1};{}$ ${}\\{cc}<\\{last\_itm};{}$ ${}\\{cc}\PP){}$\1\6
\&{if} ${}(\|o,\39\\{nd}[\\{cc}].\\{len}\E\T{0}){}$\1\5
\X41:Take note that \PB{\\{cc}} has no options\X;\2\2\6
\&{for} ${}(\\{rnd}\K\T{1};{}$ ${}\\{rnd}<\\{rounds};{}$ ${}\\{rnd}\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_choices}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Beginning\ round\ "}\|O\.{"d:\\n"},\39%
\\{rnd});{}$\2\6
\&{for} ${}(\\{change}\K\T{0},\39\|c\K\T{1};{}$ ${}\|c<\\{last\_itm};{}$ ${}\|c%
\PP){}$\1\6
\&{if} ${}(\|o,\39\\{nd}[\|c].\\{len}){}$\1\5
\X31:Try to reduce options in item \PB{\|c}'s list\X;\2\2\6
\&{if} ${}(\R\\{change}){}$\1\5
\&{break};\2\6
\4${}\}{}$\2\par
\U4.\fi

\M{30}\B\X5:Global variables\X${}\mathrel+\E{}$\6
\&{int} \\{rnd};\C{ the current round }\6
\&{int} \\{stack};\C{ a blocked item; or top of stack of options to delete }\6
\&{int} \\{change};\C{ have we removed anything on the current round? }\par
\fi

\M{31}In order to avoid testing an option repeatedly, we usually
try to remove it only when \PB{\|c} is its first element as stored in memory.

\Y\B\4\X31:Try to reduce options in item \PB{\|c}'s list\X${}\E{}$\6
${}\{{}$\1\6
\&{if} (\\{sanity\_checking})\1\5
\\{sanity}(\,);\2\6
\&{if} ${}(\\{delta}\W(\\{mems}\G\\{thresh})){}$\5
${}\{{}$\1\6
${}\\{thresh}\MRL{+{\K}}\\{delta};{}$\6
${}\\{fprintf}(\\{stderr},\39\.{"\ after\ "}\|O\.{"lld\ mems:\ "}\|O\.{"d."}\|O%
\.{"d,\ "}\|O\.{"d\ items\ out,\ "}\|O\.{"d\ options\ out\\n"},\39\\{mems},\39%
\\{rnd},\39\|c,\39\\{itms\_out},\39\\{options\_out});{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{mems}\G\\{timeout}){}$\1\5
\&{goto} \\{finish};\2\6
${}\\{stack}\K\T{0},\39\\{hide}(\|c);{}$\6
\&{if} (\\{stack})\1\5
\X32:Remove item \PB{\|c}, and maybe some options\X\2\6
\&{else}\5
${}\{{}$\1\6
\&{for} ${}(\|o,\39\|r\K\\{nd}[\|c].\\{down};{}$ ${}\|r\G\\{last\_itm};{}$ %
\|o${},\39\|r\K\\{nd}[\|r].\\{down}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|q\K\|r-\T{1};{}$ \|o${},\39\\{nd}[\|q].\\{down}\E\|q-\T{1};{}$
${}\|q\MM){}$\1\5
;\C{ bypass null spacers }\2\6
\&{if} ${}(\|o,\39\\{nd}[\|q].\\{itm}\Z\T{0}{}$)\C{ \PB{\|r} is the first
(surviving) node in its option }\1\6
\X36:Stack option \PB{\|r} for deletion if it leaves some primary item
uncoverable\X;\2\6
\4${}\}{}$\2\6
\\{unhide}(\|c);\6
\&{for} ${}(\|r\K\\{stack};{}$ \|r; ${}\|r\K\\{rr}){}$\5
${}\{{}$\1\6
${}\\{oo},\39\\{rr}\K\\{nd}[\|r].\\{itm},\39\\{nd}[\|r].\\{itm}\K\|c;{}$\6
\X40:Actually delete option \PB{\|r}\X;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U29.\fi

\M{32}\B\X32:Remove item \PB{\|c}, and maybe some options\X${}\E{}$\6
${}\{{}$\1\6
\\{unhide}(\|c);\6
\&{if} ${}(\\{vbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Deleting\ item\ "}\|O\.{".8s,\ forced\ by\ "}%
\|O\.{".8s\\n"},\39\\{cl}[\|c].\\{name},\39\\{cl}[\\{stack}].\\{name});{}$\2\6
\&{for} ${}(\|o,\39\|r\K\\{nd}[\|c].\\{down};{}$ ${}\|r\G\\{last\_itm};{}$ ${}%
\|r\K\\{rrr}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{rrr}\K\\{nd}[\|r].\\{down};{}$\6
\X33:Delete or shorten option \PB{\|r}\X;\6
\4${}\}{}$\2\6
${}\|o,\39\\{nd}[\|c].\\{up}\K\\{nd}[\|c].\\{down}\K\|c;{}$\6
${}\|o,\39\\{nd}[\|c].\\{len}\K\T{0},\39\\{itms\_out}\PP{}$;\C{ now item \PB{%
\|c} is gone }\6
${}\\{change}\K\T{1};{}$\6
\4${}\}{}$\2\par
\U31.\fi

\M{33}We're in the driver's seat here:
If option \PB{\|r} includes \PB{\\{stack}}, we keep it,
but remove item \PB{\|c}.
Otherwise we delete it.

\Y\B\4\X33:Delete or shorten option \PB{\|r}\X${}\E{}$\6
${}\{{}$\1\6
\&{for} ${}(\|q\K\|r+\T{1};{}$ ${}\|q\I\|r;{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\|q].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\|q\K\\{nd}[\|q].\\{up};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{cc}\E\\{stack}){}$\1\5
\&{break};\2\6
${}\|q\PP;{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\|q\I\|r){}$\1\5
\X34:Shorten and retain option \PB{\|r}\X\2\6
\&{else}\1\5
\X35:Delete option \PB{\|r}\X;\2\6
\4${}\}{}$\2\par
\U32.\fi

\M{34}\B\X34:Shorten and retain option \PB{\|r}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_details}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"\ shortening"});{}$\6
${}\|t\K\\{dpoption}(\|r,\39\\{stderr}),\39\\{fprintf}(\\{stderr},\39\.{"\
(option\ "}\|O\.{"d)\\n"},\39\|t);{}$\6
\4${}\}{}$\2\6
${}\|o,\39\\{nd}[\|r].\\{up}\K\|r+\T{1},\39\\{nd}[\|r].\\{down}\K\|r-\T{1}{}$;%
\C{ make node \PB{\|r} into a spacer }\6
${}\|o,\39\\{nd}[\|r].\\{itm}\K\T{0};{}$\6
\4${}\}{}$\2\par
\U33.\fi

\M{35}\B\X35:Delete option \PB{\|r}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_details}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"\ deleting"});{}$\6
${}\|t\K\\{dpoption}(\|r,\39\\{stderr}),\39\\{fprintf}(\\{stderr},\39\.{"\
(option\ "}\|O\.{"d)\\n"},\39\|t);{}$\6
\4${}\}{}$\2\6
${}\\{options\_out}\PP;{}$\6
\&{for} ${}(\|o,\39\|q\K\|r+\T{1};{}$ ${}\|q\I\|r;{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\|q].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\|q\K\\{nd}[\|q].\\{up};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\|o,\39\|t\K\\{nd}[\\{cc}].\\{len}-\T{1};{}$\6
\&{if} ${}(\|t\E\T{0}){}$\1\5
\X41:Take note that \PB{\\{cc}} has no options\X;\2\6
${}\|o,\39\\{nd}[\\{cc}].\\{len}\K\|t;{}$\6
${}\|o,\39\\{uu}\K\\{nd}[\|q].\\{up},\39\\{dd}\K\\{nd}[\|q].\\{down};{}$\6
${}\\{oo},\39\\{nd}[\\{uu}].\\{down}\K\\{dd},\39\\{nd}[\\{dd}].\\{up}\K%
\\{uu};{}$\6
${}\|q\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U33.\fi

\M{36}At this point we've hidden item \PB{\|c}. Now we will hide also the
other items in option~\PB{\|r}; we'll delete \PB{\|r} if this leaves some
other primary item uncoverable. (As soon as such an item is encountered,
we put it in \PB{\\{pp}} and immediately back up.)

But before doing that test, we stamp the \PB{\\{aux}} field of every
non-\PB{\|c} item of~\PB{\|r} with the number~\PB{\|r}. Then we'll know for
sure
whether or not we've blocked an item not in~\PB{\|r}.

When \PB{\\{cc}} is an item in option \PB{\|r}, with color \PB{\|x}, the notion
of
``hiding item \PB{\\{cc}}'' means, more precisely, that we hide every option
in \PB{\\{cc}}'s item list that clashes with option~\PB{\|r}. Option \PB{%
\\{rr}} clashes with~\PB{\|r}
if and only if either \PB{$\|x\K\T{0}$} or \PB{\\{rr}}~has \PB{\\{cc}} with a
color $\ne x$.

\Y\B\4\X36:Stack option \PB{\|r} for deletion if it leaves some primary item
uncoverable\X${}\E{}$\6
${}\{{}$\1\6
\&{for} ${}(\|q\K\|r+\T{1};{}$  ; \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\|q].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\|q\K\\{nd}[\|q].\\{up};{}$\6
\&{if} ${}(\|q>\|r){}$\1\5
\&{continue};\2\6
\&{break};\C{ done with option }\6
\4${}\}{}$\2\6
${}\|o,\39\\{nd}[\\{cc}].\\{aux}\K\|r,\39\|q\PP;{}$\6
\4${}\}{}$\2\6
\&{for} ${}(\\{pp}\K\T{0},\39\|q\K\|r+\T{1};{}$  ; \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\|q].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\|q\K\\{nd}[\|q].\\{up};{}$\6
\&{if} ${}(\|q>\|r){}$\1\5
\&{continue};\2\6
\&{break};\C{ done with option }\6
\4${}\}{}$\2\6
\&{for} ${}(\|x\K\\{nd}[\|q].\\{color},\39\|o,\39\|p\K\\{nd}[\\{cc}].%
\\{down};{}$ ${}\|p\G\\{last\_itm};{}$ \|o${},\39\|p\K\\{nd}[\|p].\\{down}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|x>\T{0}\W(\|o,\39\\{nd}[\|p].\\{color}\E\|x)){}$\1\5
\&{continue};\2\6
\X37:Hide the entries of option \PB{\|p}, or \PB{\&{goto} \\{backup}}\X;\6
\4${}\}{}$\2\6
${}\|q\PP;{}$\6
\4${}\}{}$\2\6
\4\\{backup}:\5
\&{for} ${}(\|q\K\|r-\T{1};{}$ ${}\|q\I\|r;{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\|q].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\|q\K\\{nd}[\|q].\\{down};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
\&{for} ${}(\|x\K\\{nd}[\|q].\\{color},\39\|o,\39\|p\K\\{nd}[\\{cc}].\\{up};{}$
${}\|p\G\\{last\_itm};{}$ \|o${},\39\|p\K\\{nd}[\|p].\\{up}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|x>\T{0}\W(\|o,\39\\{nd}[\|p].\\{color}\E\|x)){}$\1\5
\&{continue};\2\6
\X38:Unhide the entries of option \PB{\|p}\X;\6
\4${}\}{}$\2\6
${}\|q\MM;{}$\6
\4${}\}{}$\2\6
\&{if} (\\{pp})\1\5
\X39:Mark the unnecessary option \PB{\|r}\X;\2\6
\4${}\}{}$\2\par
\U31.\fi

\M{37}Long ago, in my paper ``Structured programming with {\bf go to}
statements''
[{\sl Computing Surveys\/ \bf 6} (December 1974), 261--301], I explained
why it's sometimes legitimate to jump out of one loop into the midst
of another. Now, after many years, I'm still jumping.

\Y\B\4\X37:Hide the entries of option \PB{\|p}, or \PB{\&{goto} \\{backup}}%
\X${}\E{}$\6
\&{for} ${}(\\{qq}\K\|p+\T{1};{}$ ${}\\{qq}\I\|p;{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\\{qq}].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{qq}\K\\{nd}[\\{qq}].\\{up};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\|o,\39\|t\K\\{nd}[\\{cc}].\\{len}-\T{1};{}$\6
\&{if} ${}(\R\|t\W\\{cc}<\\{second}\W\\{nd}[\\{cc}].\\{aux}\I\|r){}$\5
${}\{{}$\1\6
${}\\{pp}\K\\{cc};{}$\6
\&{goto} \\{midst};\C{ with fingers crossed }\6
\4${}\}{}$\2\6
${}\|o,\39\\{nd}[\\{cc}].\\{len}\K\|t;{}$\6
${}\|o,\39\\{uu}\K\\{nd}[\\{qq}].\\{up},\39\\{dd}\K\\{nd}[\\{qq}].\\{down};{}$\6
${}\\{oo},\39\\{nd}[\\{uu}].\\{down}\K\\{dd},\39\\{nd}[\\{dd}].\\{up}\K%
\\{uu};{}$\6
${}\\{qq}\PP;{}$\6
\4${}\}{}$\2\par
\U36.\fi

\M{38}\B\X38:Unhide the entries of option \PB{\|p}\X${}\E{}$\6
\&{for} ${}(\\{qq}\K\|p-\T{1};{}$ ${}\\{qq}\I\|p;{}$ \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\\{qq}].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\\{qq}\K\\{nd}[\\{qq}].\\{down};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\\{oo},\39\\{nd}[\\{cc}].\\{len}\PP;{}$\6
${}\|o,\39\\{uu}\K\\{nd}[\\{qq}].\\{up},\39\\{dd}\K\\{nd}[\\{qq}].\\{down};{}$\6
${}\\{oo},\39\\{nd}[\\{uu}].\\{down}\K\\{nd}[\\{dd}].\\{up}\K\\{qq};{}$\6
\4\\{midst}:\5
${}\\{qq}\MM;{}$\6
\4${}\}{}$\2\par
\U36.\fi

\M{39}When I first wrote this program, I reasoned as follows:
``Option \PB{\|r} has been hidden. So if we remove it from list~\PB{\|c}, the
operation \PB{\\{unhide}(\|c)} will keep it hidden. (And that's precisely
what we want.)''

Boy, was I wrong! This change to list~\PB{\|c} fouled up the \PB{\\{unhide}}
routine,
because things were not properly restored/undone after the list no longer
told us to undo them. (Undeleted options are mixed with deleted ones.)

The remedy is to mark the option, for deletion {\it later}.
The marked options are linked together via their \PB{\\{itm}} fields, which
will no longer be needed for their former purpose.

\Y\B\4\X39:Mark the unnecessary option \PB{\|r}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_details}){}$\5
${}\{{}$\1\6
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{".8s\ blocked\ by"},\39\\{cl}[%
\\{pp}].\\{name});{}$\6
${}\|t\K\\{dpoption}(\|r,\39\\{stderr}),\39\\{fprintf}(\\{stderr},\39\.{"\
(option\ "}\|O\.{"d)\\n"},\39\|t);{}$\6
\4${}\}{}$\2\6
${}\\{options\_out}\PP,\39\\{change}\K\T{1};{}$\6
${}\|o,\39\\{nd}[\|r].\\{itm}\K\\{stack},\39\\{stack}\K\|r;{}$\6
\4${}\}{}$\2\par
\U36.\fi

\M{40}\B\X40:Actually delete option \PB{\|r}\X${}\E{}$\6
\&{for} ${}(\|p\K\|r+\T{1};{}$  ; \,)\5
${}\{{}$\1\6
${}\|o,\39\\{cc}\K\\{nd}[\|p].\\{itm};{}$\6
\&{if} ${}(\\{cc}\Z\T{0}){}$\5
${}\{{}$\1\6
${}\|o,\39\|p\K\\{nd}[\|p].\\{up};{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}\|o,\39\\{uu}\K\\{nd}[\|p].\\{up},\39\\{dd}\K\\{nd}[\|p].\\{down};{}$\6
${}\\{oo},\39\\{nd}[\\{uu}].\\{down}\K\\{dd},\39\\{nd}[\\{dd}].\\{up}\K%
\\{uu};{}$\6
${}\\{oo},\39\\{nd}[\\{cc}].\\{len}\MM;{}$\6
\&{if} ${}(\\{nd}[\\{cc}].\\{len}\E\T{0}){}$\1\5
\X41:Take note that \PB{\\{cc}} has no options\X;\2\6
\&{if} ${}(\|p\E\|r){}$\1\5
\&{break};\2\6
${}\|p\PP;{}$\6
\4${}\}{}$\2\par
\U31.\fi

\M{41}\B\X41:Take note that \PB{\\{cc}} has no options\X${}\E{}$\6
${}\{{}$\1\6
${}\\{itms\_out}\PP;{}$\6
\&{if} ${}(\\{cc}\G\\{second}){}$\5
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"\ "}\|O\.{".8s\ is\ in\ no\ option}\)\.{s%
\\n"},\39\\{cl}[\\{cc}].\\{name});{}$\2\6
\4${}\}{}$\5
\2\&{else}\1\5
\X42:Terminate with unfeasible item \PB{\\{cc}}\X;\2\6
\4${}\}{}$\2\par
\Us29, 35\ETs40.\fi

\M{42}We might find a primary item that appears in no options. In such
a case {\it all\/} of the options can be deleted, and all of the
other items!

\Y\B\4\X42:Terminate with unfeasible item \PB{\\{cc}}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{vbose}\AND\\{show\_details}){}$\1\5
${}\\{fprintf}(\\{stderr},\39\.{"Primary\ item\ "}\|O\.{".8s\ is\ in\ no\
option}\)\.{s!\\n"},\39\\{cl}[\\{cc}].\\{name});{}$\2\6
${}\\{options\_out}\K\\{options};{}$\6
${}\\{itms\_out}\K\\{last\_itm}-\T{1};{}$\6
${}\\{printf}(\.{""}\|O\.{".8s\\n"},\39\\{cl}[\\{cc}].\\{name}){}$;\C{ this is
the only line of output }\6
\&{goto} \\{all\_done};\6
\4${}\}{}$\2\par
\U41.\fi

\N{1}{43}The output phase. Okay, we're done!

\Y\B\4\X43:Output the reduced problem\X${}\E{}$\6
\X44:Output the item names\X;\6
\X45:Output the options\X;\par
\U4.\fi

\M{44}\B\X44:Output the item names\X${}\E{}$\6
\&{for} ${}(\|c\K\T{1};{}$ ${}\|c<\\{last\_itm};{}$ ${}\|c\PP){}$\5
${}\{{}$\1\6
\&{if} ${}(\|c\E\\{second}){}$\1\5
\\{printf}(\.{"\ |"});\2\6
\&{if} ${}(\|o,\39\\{nd}[\|c].\\{len}){}$\1\5
${}\\{printf}(\.{"\ "}\|O\.{".8s"},\39\\{cl}[\|c].\\{name});{}$\2\6
\4${}\}{}$\2\6
\\{printf}(\.{"\\n"});\par
\U43.\fi

\M{45}\B\X45:Output the options\X${}\E{}$\6
\&{for} ${}(\|c\K\T{1};{}$ ${}\|c<\\{last\_itm};{}$ ${}\|c\PP){}$\1\6
\&{if} ${}(\|o,\39\\{nd}[\|c].\\{len}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|o,\39\|r\K\\{nd}[\|c].\\{down};{}$ ${}\|r\G\\{last\_itm};{}$ %
\|o${},\39\|r\K\\{nd}[\|r].\\{down}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|q\K\|r-\T{1};{}$ \|o${},\39\\{nd}[\|q].\\{down}\E\|q-\T{1};{}$
${}\|q\MM){}$\1\5
;\2\6
\&{if} ${}(\|o,\39\\{nd}[\|q].\\{itm}\Z\T{0}){}$\5
${}\{{}$\C{ \PB{\|r} was the leftmost survivor in its option }\1\6
${}\|t\K\\{dpoption}(\|r,\39\\{stdout});{}$\6
\\{printf}(\.{"\\n"});\6
\&{if} ${}(\\{vbose}\AND\\{show\_orig\_nos}){}$\1\5
${}\\{printf}(\.{"|\ (from\ "}\|O\.{"d)\\n"},\39\|t);{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\2\par
\U43.\fi

\N{1}{46}Index.
\fi

\inx
\fin
\con
